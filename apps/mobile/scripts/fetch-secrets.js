
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

const projectId = process.env.GCP_PROJECT_ID || 'agent-gen-1';

// Mapping: GSM Secret Name -> Local Env Var Name (NEXT_PUBLIC_ prefix for Next.js)
const SECRET_MAPPING = {
    'SUPABASE_URL': 'NEXT_PUBLIC_SUPABASE_URL',
    'SUPABASE_ANON_KEY': 'NEXT_PUBLIC_SUPABASE_ANON_KEY',
    'STRIPE_PUBLISHABLE_KEY': 'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY',
    'BACKEND_URL': 'NEXT_PUBLIC_BACKEND_URL',
    'APP_URL': 'NEXT_PUBLIC_APP_URL'
};

async function fetchSecrets() {
    console.log('ğŸ” Fetching secrets from Google Secret Manager (via gcloud CLI)...');
    let envContent = '# Auto-generated by fetch-secrets.js at build time\n';

    for (const [secretName, envVarName] of Object.entries(SECRET_MAPPING)) {
        try {
            // Use gcloud CLI directly as it shares the user's active session reliably
            const payload = execSync(`gcloud secrets versions access latest --secret=${secretName} --project=${projectId}`, { encoding: 'utf-8' }).trim();
            if (payload) {
                envContent += `${envVarName}=${payload}\n`;
                console.log(`  âœ… Loaded ${secretName} -> ${envVarName}`);
            } else {
                console.warn(`  âš ï¸ Empty payload for ${secretName}`);
            }
        } catch (error) {
            console.error(`  âŒ Failed to fetch ${secretName}:`, error.message);
            throw error; // Fail the build
        }
    }

    const envPath = path.resolve(process.cwd(), '.env.local');
    fs.writeFileSync(envPath, envContent);
    console.log(`âœ… Secrets written to ${envPath}`);
}

fetchSecrets().catch(err => {
    console.error('âŒ Fatal error fetching secrets:', err);
    process.exit(1);
});
