
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

const projectId = process.env.GCP_PROJECT_ID || 'agent-gen-1';

// Mapping: GSM Secret Name -> Local Env Var Name
const SECRET_MAPPING = {
    'SUPABASE_URL': 'VITE_SUPABASE_URL',
    'SUPABASE_ANON_KEY': 'VITE_SUPABASE_ANON_KEY',
    'STRIPE_PUBLISHABLE_KEY': 'VITE_STRIPE_PUBLISHABLE_KEY',
    'AGENT_GATEWAY_URL': 'VITE_AGENT_GATEWAY_URL',
    'APP_URL': 'VITE_APP_URL',
    'BACKEND_URL': 'VITE_BACKEND_URL'
};

async function fetchSecrets() {
    console.log('ğŸ” Fetching secrets from Google Secret Manager (via gcloud CLI)...');
    let envContent = '# Auto-generated by fetch-secrets.ts at build time\n';

    for (const [secretName, envVarName] of Object.entries(SECRET_MAPPING)) {
        try {
            // Use gcloud CLI directly as it shares the user's active session reliably
            const payload = execSync(`gcloud secrets versions access latest --secret=${secretName} --project=${projectId}`, { encoding: 'utf-8' }).trim();
            if (payload) {
                envContent += `${envVarName}=${payload}\n`;
                console.log(`  âœ… Loaded ${secretName} -> ${envVarName}`);
            } else {
                console.warn(`  âš ï¸ Empty payload for ${secretName}`);
            }
        } catch (error) {
            console.error(`  âŒ Failed to fetch ${secretName}:`, (error as Error).message);
            throw error; // Fail the build
        }
    }

    const envPath = path.resolve(process.cwd(), '.env.local');
    fs.writeFileSync(envPath, envContent);
    console.log(`âœ… Secrets written to ${envPath}`);
}

fetchSecrets().catch(err => {
    console.error('âŒ Fatal error fetching secrets:', err);
    process.exit(1);
});
